\documentclass[twocolumn]{article}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{svg}
\usepackage{pdfpages}
%%\usepackage{floatrow}

\graphicspath{ {./assets/images/} }

%links
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

%Pseudocode
\usepackage[german,vlined,longend,ruled,linesnumbered]{algorithm2e}
\SetKw{KwDownTo}{downto}
\SetKw{KwAnd}{and}
\SetKw{KwOr}{or}
\SetKwBlock{DoParallel}{do in parallel}{end}
\usepackage{xcolor}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}
\DontPrintSemicolon

\newcommand{\aetitle}{Efficiently updating Customizable Contraction Hierarchies} % Title of the 

\newcommand{\studentOne}{Marius Hahn} % Name 2

\begin{document}

\input{assets/title}

\section{Intro}

This is a seminar on "Efficient shortest path index maintenance on dynamic
road networks with theoretical guarantees" \cite{Ouyang2020}. The paper is
about finding the shortest path in road networks. By \textit{shortest} it is meant,
the path that requires the less time to get from source $s$ to a target $t$. The route
network is modeled as a directed graph $G(V,E)$ where each street crossing represents a
vertex $v \epsilon V$ and each road between crossings represents an edge $e \epsilon E$.
The most basic and solid method to find shortest paths between vertices in a graph is
Dijkstra's algorithm \cite{Dijkstra1959}. This algorithm is proofed to always return the
correct shortest path but it is not fast enough for just in time route planning on large
road networks as we know it from services like Google Maps.
\\
There are many
different approaches that try to speed up shortest path queries by precomputing
any different kind of index structure before doing the shortest path query. The index
structure discussed in here \cite{Ouyang2020} is CH (Contraction Hierarchies)\cite{Geisberger2012}
with some extension. This extension is CCH (Customizable Contraction Hierarchies)
\cite{Dibbelt2014}. Although the authors of \cite{Ouyang2020} never mention the term
CCH their approaches builds the same index structure. This is a pity, as for this part
they kind of reinvent the wheel.
\\
The difference lies in updating
the CCH index structure. For updating the CCH, the authors of \cite{Ouyang2020} will use yet another
index structure called \textit{SS-Graph} that helps to exactly identify the shortcuts that
have to be updated, after some edge weight has changed. In todays implementation, the whole
index structure is recomputed periodically. This is an valid approach as it is fast enough
to stay accurate for route planning in road networks.
\\
In \cite{Ouyang2020} the authors would like to find a way that make it possible to handle streaming
updates. Therefore it is necessary to handle single weight decreases
and increases. To do so another index structure the \textit{SS-Graph} is introduced.
This index structure is a helper structure to identify the shortcuts
that have to be updated in the CCH.
\\
The disadvantage of this \textit{SS-Graph} is that the overall space consumption rises.
This can be a deal breaker for large networks.
Finally they introduce a way to create the necessary \textit{SS-Graph} on the fly. Which
is only a part of the whole structure.
Sadly the exact way, how, is missing in the paper \cite{Ouyang2020}.


\section{Shortcut Supporting Graph}

\begin{figure}[h]
    \caption{Base Graph $G$}
    \centering
    \includegraphics[width=\linewidth]{baseGraph}
    \label{fig:baseGraph}
\end{figure}

This section is about the \textit{Shortcut Supporting Graph} introduced in \cite{Ouyang2020}.
The way how the shortcut index is created is omitted because it is a Customizable Contraction
Hierarchies shortcut index and therefore not of further interest. Although the algorithm to get
there is described differently the result is a shortcut index that encodes every simple path.
This is the same in CCH.
\\
Figure \ref{fig:baseGraph} represents the sample base graph which is used as an example graph 
throughout this whole work. It is the same as used in \cite{Ouyang2020}, but redrawn.

\begin{figure}[h]
    \caption{Shortcut Index Graph $G'$}
    \centering
    \includegraphics[width=\linewidth]{cchGraph}
    \label{fig:shortcutIndex}
\end{figure}

Figure \ref{fig:shortcutIndex} represents the \textit{Shortcut Index G'} already materialized. The red numbers
located just outside the vertices represent the contraction order. The numbers on the edge are the weight
assigned to the edge. The inserted shortcuts are drawn in blue and have their weight already assigned, too.

Based on this \textit{Shortcut Index G'} yet another index structure is introduced. The \textit{Shortcut Supporting Graph G*}.
$G*$ is a directed graph that has two different kind of vertices. The first vertex set $V_s$ represents all the
edges that are contained in the \textit{Shortcut Index G'}. The second vertex set are the relation type 
vertices $V_r$. A relation type vertex $v_r$ has two in-neighbors $v_{s1}$ and $v_{s2}$ that and one 
out neighbor $v_{s3}$. Each vertex in $V_s$ has three properties. 

\begin{itemize}
    \item The edge or shortcut $e = (v_u, v_v)$ in $G'$ it represents
    \item The shortest path cost $\phi(e)$ 
    \item The number of relation type vertices that support this edge or shortcut and lye on the shortest path $c_{\phi}(e)$
\end{itemize}

Figure \ref{fig:SsGraph} is the \textit{Shortcut Supporting Graph G*} of \textit{Shortcut Index G'}.
\\
\paragraph{Example 1:} Lets take this most upper vertex of $G*$ in figure \ref{fig:SsGraph}. It represents
the shortcut $e= (v_0, v_5)$. This shortcut is supported through four other simple paths in G' of two hops.
\begin{enumerate}
    \item $R_1$ with the two in neighbors $v_{s1} = (v_7, v_5)$ and $v_{s2} = (v_7, v_0)$ with total path cost $\phi = \phi(v_{s1}) + \phi_{v_{s2}} = 8$
    \item $R_2$ with the two in neighbors $v_{s1} = (v_4, v_5)$ and $v_{s2} = (v_4, v_0)$ with total path cost $\phi = \phi(v_{s1}) + \phi_{v_{s2}} = 5$
    \item $R_5$ with the two in neighbors $v_{s1} = (v_6, v_5)$ and $v_{s2} = (v_6, v_0)$ with total path cost $\phi = \phi(v_{s1}) + \phi_{v_{s2}} = 7$
    \item $R_6$ with the two in neighbors $v_{s1} = (v_2, v_5)$ and $v_{s2} = (v_0, v_5)$ with total path cost $\phi = \phi(v_{s1}) + \phi_{v_{s2}} = 7$
\end{enumerate}

$c_{\phi}(e) = 1$ as only $R_2$ is on the shortest path that has length five. 

\begin{figure*}[t]
    \caption{Shortcut Support Index $G*$}
    \centering
    \includegraphics[width=\textwidth]{SsGraph}
    \label{fig:SsGraph}
\end{figure*}

\subsection{Space Consumption} \label{Space Consumption}

The space consumption of $G*$ is: 
\\
$\mathcal{O}(\vert E(G') \vert + \sum_{v \epsilon  V(G')}(\vert Nbr(v) \vert * (\vert Nbr(v) \vert-1)/2))$
where $Nbr(v) = {u\vert u \epsilon nbr(v) \land \gamma(u) > \gamma(v) }$ and $\gamma(u)$ is the rank of vertex $u$.
This is a lot more than $G'$ and can be a problem in practice. Due to the authors there exist an algorithm in their
\textit{long version of the paper} that does not need to materialize the $G*$. Sadly this 
\href{https://www.dropbox.com/s/3s7n9u1sv315785/DynSDist.pdf?dl=0}{link} is broken. 


\section{Reaction on Weight Changes}

Here we will have a look what happens on a weight decrease or increase. 
In CCH for the whole shortcut index is updated in a fixed time interval. We want to 
do streaming updates which means react to a single weight change. In classic
CCH you usually have to recontract at least all vertices with a higher rank than
the once that form the endpoint of the updated edge. Having the \textit{Shortcut Support Index $G*$}
it is possible to determine which edges have to be updated. In general this could
be the same amount of edges but in real applications this is very unlikely.

\subsection{Weight Decrease}

In this case a single edge weight decrease. The algorithm in figure \ref{fig:decreaseAlgorithm} 
show what to do in this case. The update of the support counter $c_{\phi}$ is omitted as
figure \ref{fig:decreaseAlgorithm} is copied from \cite{Ouyang2020} and it was omitted there, too. The support counter $c_{\phi}$
isn't needed for the decrease case to work but it is needed in the decrease case to later on 
work together with the increase case. Fixing this is out of the scope for this work. Therefore the 
algorithm is presented as is in figure \ref{fig:decreaseAlgorithm}. 

\begin{figure}[ht]
    \caption{Shortcut Index Graph $G'$}
    \centering
    \includegraphics[width=\linewidth]{decreaseAlgorithm}
    \label{fig:decreaseAlgorithm}
\end{figure}

What this algorithm basically does is, when a weight decreases happens it looks for shortcuts that are build upon this edge.
If the weight of this shortcut doesn't depend on the edge it stops. If the weight of this shortcut depends on the edge, 
meaning the edge was lying on the shortest path, it updates the weight of the shortcut. This happens recursively.

This guarantees that only edges that are one hop dependent on a changed edge are explored. Therefore the time complexity 
of this algorithm is $\mathcal{O}(\vert\Delta\vert  * (log \vert \Delta \vert + deg'_{max}) + 1)$.  $\vert\Delta\vert$ is the
number of shortcuts that have to be updated and $deg'_{max}$. 
In the worst case $\vert\Delta\vert$ are all edges and shortcuts that have a vertex involved with a higher rank than in the changed edge $e$.
In practice this is very unlikely. In section \ref{Experimental Results} it is stated that the it actually outperforms CCH.

Because it is ineffective and difficult to describe this algorithm in words there is a step by step slide show attached to this
paper, that shows how it behaves. 

\subsection{Weight Increase}
In this case a single edge weight increase. The algorithm in figure \ref{fig:increaseAlgorithm} 
show what to do in this case. It basically works in the same manner as the decrease case.

As for the decrease case it guarantees that only edges that are one hop dependent on a changed edge are explored. Therefore the time complexity 
of this algorithm is $\mathcal{O}(\vert\Delta\vert  * (log \vert \Delta \vert + deg'_{max}) + 1)$.  $\vert\Delta\vert$ is the
number of shortcuts that have to be updated and $deg'_{max}$. \cite{Ouyang2020}

\begin{figure}[ht]
    \caption{Shortcut Index Graph $G'$}
    \centering
    \includegraphics[width=\linewidth]{increaseAlgorithm}
    \label{fig:increaseAlgorithm}
\end{figure}

Because it is ineffective and difficult to describe this algorithm in words there is a step by step slide show attached to this
paper, that shows how it behaves. 

\section{Experimental Results} \label{Experimental Results}

The decrease and increase algorithm have been experimentally evaluated against CCH and CRP. We will only regard the difference between 
CCH and the algorithms in figure \ref{fig:increaseAlgorithm} and figure \ref{fig:decreaseAlgorithm} as well as their equivalent
that doesn't materialize the \textit{Shortcut Support Index $G*$}.  \cite{Ouyang2020}

\subsection{Dataset}
The dataset that was used for the experiments comes from \href{http://www.dis.uniroma1.it/challenge9/download.shtml}{here}.
These are real world public road networks in the US.

\subsection{Space Consumption}

As already mentioned in \ref{Space Consumption} the \textit{Shortcut Support Index $G*$} consumes a lot more memory than 
the \textit{Shortcut Index G'}. For the dataset they tried out in \cite{Ouyang2020} it used between 12.7 and 34.6 times more
memory that $G'$, depending on the dataset that was used. This can be avoided when using the on the fly algorithm that, doesn't 
materialize $G*$. Sadly it wasn't provided in the paper and neither was the code with which they made their experiments.

\subsection{Weight Changes Performance}

The authors randomly picked 1000 edges, changed their weight and updated the \textit{Shortcut Index G'}. For the decrease case 
the proposed algorithms in figure \ref{fig:decreaseAlgorithm} and figure \ref{fig:increaseAlgorithm} outperformed 
CCH by order of magnitude 2 ~ 3. The not provided algorithms that work without materializing the \textit{Shortcut Support Index $G*$}
claims to be as fast as the materialized one.

\section{Conclusion}

The generally idea of providing a streaming algorithm for updating a CCH shortcut index. The algorithms in \cite{Ouyang2020} are
promising, but the whole evaluation should be redone. First of all it should be categorized as \textit{CCH} and not \textit{DCH} – a term that
wasn't even mentioned in the paper they based their research on \cite{Geisberger2012}. Secondly they should provide the 
algorithms for the non materialized manner or \textit{the long version of the paper \cite{Ouyang2020}}. Finally, why isn't there
any link to the source code which they used to test their idea?

In my opinion the idea itself is valid but the actual paper would need some additional work in terms of properly categorizing the topic,
and also some transparency regarding the implementation and the experimentally evaluation.

\newpage

\bibliographystyle{plain}
\bibliography{assets/references} 
\listoffigures

\newpage

\includepdf[pages=-, landscape=true]{weightDecrease.pdf} 
\includepdf[pages=-, landscape=true]{weightIncrease.pdf} 


\end{document}
